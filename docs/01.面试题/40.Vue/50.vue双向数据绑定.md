---
title: vue双向数据绑定
date: 2019-06-10 19:09:14
permalink: /pages/24cdd2f50e3cd/
categories:
  - 面试题
  - Vue
tags:
  -
---

- vue 数据双向绑定的原理
- 实现简单版 vue 的过程，主要实现{{}}、v-model 和事件指令的功能

<!-- more -->

## vue 双向绑定原理

vue 双向绑定原理是通过数据劫持结合发布者-订阅者模式的方式来实现的

```js
var vm = new Vue({
  data: {
    obj: {
      a: 1,
    },
  },
  created() {
    console.log(this.obj);
  },
});
```

![20210624231615](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20210624231615.png)

我们可以看到属性 a 有两个相对应的属性 get 和 set 方法

为什么会多出这两个方法呢？因为 vue 是通过 Object.defineProperty()来实现数据劫持的。

Object.defineProperty( )是用来做什么的？

它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，

这里我们主要先来研究下它对应的两个描述属性 get 和 set，

如果还不熟悉其用法，[请点击这里阅读更多用法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)。

在平常，我们很容易就可以打印出一个对象的属性数据：

```js
var Book = {
  name: "vue权威指南",
};
console.log(Book.name); // vue权威指南
```

如果想要在执行 console.log(book.name)的同时，直接给书名加个书名号，那要怎么处理呢？或者说要通过什么监听对象 Book 的属性值。

这时候 Object.defineProperty( )就派上用场了，代码如下：

```js
var Book = {};
var name = "";
Object.defineProperty(Book, "name", {
  set: function(value) {
    name = value;
    console.log("你取了一个名字" + value);
  },
  get: function() {
    return "《" + name + "》";
  },
});
Book.name = "shenzjd.com";
console.log(Book.name);
```

## mvvm 双向绑定

实现 mvvm 主要包含两个方面，数据变化更新视图，视图变化更新数据

![20210624232349](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20210624232349.png)

### 思路

关键点在于 data 如何更新 view，因为 view 更新 data 其实可以通过事件监听即可，比如 input 标签监听 'input' 事件就可以实现了。所以我们着重来分析下，当数据改变，如何更新视图的。

数据更新视图的重点是如何知道数据变了，只要知道数据变了，那么接下去的事都好处理。如何知道数据变了，其实上文我们已经给出答案了，就是通过 Object.defineProperty( )对属性设置一个 set 函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现 data 更新 view 了

![20210624232520](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20210624232520.png)

### 实现

我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器 Observer，用来监听所有属性。

如果属性发生变化了，就需要告诉订阅者 Watcher 看是否需要更新。

因为订阅者是有很多个，所以我们需要有一个消息订阅器 Dep 来专门收集这些订阅者，然后在监听器 Observer 和订阅者 Watcher 之间进行统一管理的

我们还需要有一个指令解析器 Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者 Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者 Watcher 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。

因此接下去我们执行以下 3 个步骤，实现数据的双向绑定：

1. 实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
2. 实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
3. 实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

![20210624232812](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20210624232812.png)

#### 实现一个 Observer

数据监听器，核心方法就是前文所说的 Object.defineProperty()

所有属性，递归遍历

```js
function defineReactive(data, key, val) {
  observe(val); // 递归遍历所有子属性
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      return val;
    },
    set: function(newVal) {
      val = newVal;
      console.log(`属性${key}已经被监听到了，现在的值为${newVal.toString()}`);
    },
  });
}

function observe(data) {
  if (!data || typeof data !== "object") return;
  Object.keys(data).forEach(function(key) {
    defineReactive(data, key, data[key]);
  });
}

// demo

var library = {
  book1: {
    name: "",
  },
  book2: "",
};
observe(library);
library.book1.name = "vue权威指南"; // 属性name已经被监听了，现在值为：“vue权威指南”
library.book2 = "没有此书籍"; // 属性book2已经被监听了，现在值为：“没有此书籍”
```

需要一个容纳订阅者的消息订阅器 Dep，主要负责收集订阅者，然后在属性变化的时候执行对应订阅者的更新函数。

这个容器就是 list

改造上面代码

```js
function defineReactive(data, key, val) {
  observe(val); // 递归遍历所有子属性
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      if (是否需要添加订阅者) {
        dep.addSub(watcher); // 添加订阅者
      }
      return val;
    },
    set: function(newVal) {
      val = newVal;
      console.log(`属性${key}已经被监听到了，现在的值为${newVal.toString()}`);
      dep.notify(); // 如果数据变化，通知订阅者
    },
  });
}

function observe(data) {
  if (!data || typeof data !== "object") return;
  Object.keys(data).forEach(function(key) {
    defineReactive(data, key, data[key]);
  });
}

function Dep() {
  this.subs = [];
}

Dep.prototype = {
  addSub: function(sub) {
    this.subs.push(sub);
  },
  notify: function() {
    this.subs.forEach(function(sub) {
      sub.update();
    });
  },
};
```

从代码上看，我们将订阅器 Dep 添加一个订阅者设计在 getter 里面，这是为了让 Watcher 初始化进行触发，因此需要判断是否要添加订阅者

在 setter 函数里面，如果数据变化，就会去通知所有订阅者，订阅者们就会去执行对应的更新的函数

#### 实现 Watcher

订阅者 Watcher 在初始化的时候需要将自己添加进订阅器 Dep 中，那该如何添加呢？我们已经知道监听器 Observer 是在 get 函数执行了添加订阅者 Wather 的操作的，所以我们只要在订阅者 Watcher 初始化的时候触发对应的 get 函数去执行添加订阅者操作即可，那要如何触发 get 的函数，再简单不过了，只要获取对应的属性值就可以触发了，核心原因就是因为我们使用了 Object.defineProperty( )进行数据监听

这里还有一个细节点需要处理，我们只要在订阅者 Watcher 初始化的时候才需要添加订阅者，所以需要做一个判断操作，因此可以在订阅器上做一下手脚：在 Dep.target 上缓存下订阅者，添加成功后再将其去掉就可以了

```js
function Watcher(vm, exp, cb) {
  this.cb = cb;
  this.vm = vm;
  this.exp = exp;
  this.value = this.get(); // 将自己添加到订阅器的操作
}

Watcher.prototype = {
  update: function() {
    this.run();
  },
  run: function() {
    var value = this.vm.data[this.exp];
    var oldVal = this.value;
    if (value !== oldVal) {
      this.value = value;
      this.cb.call(this.vm, value, oldVal);
    }
  },
  get: function() {
    Dep.target = this; // 缓存自己
    var value = this.vm.data[this.exp]; // 强制执行监听器里的get函数
    Dep.target = null; // 释放自己
    return value;
  },
};
```
这时候，我们需要对监听器Observer也做个稍微调整，主要是对应Watcher类原型上的get函数。需要调整地方在于defineReactive函数：

```js


```

## 参考链接

- <https://www.cnblogs.com/canfoo/p/6891868.html>
