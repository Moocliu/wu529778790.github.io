---
title: 并行限制的Promise
date: 2022-01-18 18:41:09
permalink: /pages/1a87f65a58693/
categories:
  - 面试题
  - 手写系列
tags:
  -
---

知耻而后勇

<!-- more -->

JS 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个。完善下面代码的 Scheduler 类，使以下程序能够正常输出：

```js
class Scheduler {
  constructor() {
    this.queue = [];
    this.maxCount = 2;
    this.runCounts = 0;
  }
  add(promiseCreator) {
    this.queue.push(promiseCreator);
  }
  taskStart() {
    for (let i = 0; i < this.maxCount; i++) {
      this.request();
    }
  }
  request() {
    if (!this.queue || !this.queue.length || this.runCounts >= this.maxCount) {
      return;
    }
    this.runCounts++;

    this.queue
      .shift()()
      .then(() => {
        this.runCounts--;
        this.request();
      });
  }
}

const timeout = (time) =>
  new Promise((resolve) => {
    setTimeout(resolve, time);
  });

const scheduler = new Scheduler();

const addTask = (time, order) => {
  scheduler.add(() => timeout(time).then(() => console.log(order)));
};

addTask(1000, "1");
addTask(500, "2");
addTask(300, "3");
addTask(400, "4");

// output: 2 3 1 4
```

可以看到，最多时存在两个并行的 Promise，并且一个 Promise 执行完成之后，执行新的 Promise，并且新执行的 Promise 不会影响到另一个正在执行的 Promise。

既然如此的话，就不能使用 Promise.all()和 Promise.race()这两个 API 了，Promise.all()会等待所有 Promise 完成，Promise.race()只会执行一个 Promise。

其实从 Promise 依序进行执行，可以使用队列先进先出的特性，add 操作知识每次用队列中插入 Promise Creator，判断当前执行数量是否小于 2，如果小于 2 就从队列中弹出 Promise Creator 执行并给执行的 Promise 绑定 then 函数，then 函数被调用就说明当前 Promise 已经执行完成，重复当前操作，可以看出是一个`递归`的操作。

```js
function limitRequest(limit, requestes) {
  let runCount = 0;
  const request = () => {
    if (!requestes || !requestes.length || runCount >= limit) {
      return;
    }
    runCount++;
    requestes
      .shift()()
      .then(() => {
        runCount--;
        request();
      });
  };
  for (let i = 0; i < limit; i++) {
    request();
  }
}
const timeout = (time) =>
  new Promise((resolve) => {
    setTimeout(resolve, time);
  });
const requestes = [
  () => timeout(1000).then(() => console.log(11)),
  () => timeout(500).then(() => console.log(22)),
  () => timeout(300).then(() => console.log(33)),
  () => timeout(400).then(() => console.log(44)),
];
limitRequest(2, requestes);
```

## 参考链接

- <https://juejin.cn/post/6854573217013563405>
