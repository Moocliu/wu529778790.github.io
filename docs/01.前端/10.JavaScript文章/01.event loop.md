---
title: event loop
date: 2021-06-07 15:22:32
permalink: /pages/2f4905/
categories:
  - 前端
  - JavaScript文章
tags:
  -
---

## 几张动图带你回顾event loop

### 为什么会出现事件循环

js 是单线程的，一次只能运行一个任务。

- 为什么是单线程？

  1. 设计之初没有这样的需求，起初 js 只是脚本语言能做的事情很少，并且多线程会增加复杂性和内存消耗，所以单线程足以。这点在 node 上也有体现，node 默认只能调用 2g 的内存，其实也间接说明了 js 的应用场景的限制
  2. 防止两个线程同时操作 dom 的冲突，解决冲突会让浏览器变得更复杂
  3. js 目前也是支持多线程的，不过除了主线程其他线程都是不能操作 dom 的，这也间接印证了前面的两点，除了 dom 的操作冲突，其实用多线程挺好用的。多线程一般用于需要消耗时间的计算操作。

- 如果是单线程，遇到一个耗时的任务，则阻塞太长。所以出现了时间循环机制

  浏览器为我们提供了 JavaScript 引擎本身不提供的一些功能：Web API。这包括 DOM API，setTimeout，HTTP 请求等。这可以帮助我们创建一些异步的，非阻塞的行为。

  <!-- more -->

### 初次见面

当我们调用一个函数时，它会被添加到一个叫做调用栈的东西中。调用堆栈是 JS 引擎的一部分，这与浏览器无关。它是一个堆栈，意味着它是先入后出的（想想一堆薄饼）。当一个函数返回一个值时，它被从堆栈中弹出。

![640](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/640.gif)

响应函数返回一个 setTimeout 函数。setTimeout 是由 Web API 提供给我们的：它让我们在不阻塞主线程的情况下延迟任务。我们传递给 setTimeout 函数的回调函数，箭头函数（）=> { return 'Hey' }被添加到 Web API 中。同时，setTimeout 函数和 response 函数被从堆栈中弹出，它们都返回了它们的值!

![6401](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/6401.gif)

在 Web API 中，定时器的运行时间与我们传递给它的第二个参数一样长，即 1000ms。回调并不立即被添加到调用栈中，而是被传递到一个叫做队列的东西中

![642](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/642.gif)

### 揭开面纱

现在是我们一直在等待的部分，是时候让事件循环完成它唯一的任务了：将队列和调用栈连接起来。如果调用栈是空的，那么如果所有先前调用的函数都已经返回了它们的值，并且已经从栈中弹出，那么队列中的第一个项目就会被添加到调用栈中。在这种情况下，没有其他函数被调用，也就是说，当回调函数成为队列中的第一项时，调用栈是空的。

![643](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/643.gif)

回调被添加到调用堆栈，被调用，并返回一个值，然后被从堆栈中弹出，如图

![644](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/644.gif)

### 例子

```js
const foo = () => console.log("First");
const bar = () => setTimeout(() => console.log("Second"), 500);
const baz = () => console.log("Third");

bar();
foo();
baz();
```

虽然看起来很简单，嗯，可以尝试搞一下:

打开我们的浏览器，跑一下上面的代码，让我们快速看一下在浏览器中运行此代码时发生的情况：

![645](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/645.gif)

参考:<https://mp.weixin.qq.com/s/JpGW0pJWz-ch1M5NVF-I5g>
