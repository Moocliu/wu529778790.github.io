# 正则表达式

## 匹配字符

### 横向匹配

ab{2,5}c => abc abbc abbbc

### 纵向匹配

ab[123]c => ab1c ab2c ab3c

### match

string.match() => 返回的是匹配项的数组[]

### 范围表示(字符组)

[1-9a-fA-F] => [123456789abcdefABCDEF]  
如果要表示-，可以这么写
[-123][123-][1\-23]

### 排除字符组

[^123] => 非 1 或 2 或 3

### 简写

![1635173224(1)](<https://cdn.jsdelivr.net/gh/wu529778790/image/blog/1635173224(1).png>)

### 匹配任意字段

[\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个。

### 量词

![1635173263(1)](<https://cdn.jsdelivr.net/gh/wu529778790/image/blog/1635173263(1).png>)

### 贪婪匹配与惰性匹配

![20211025224855](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20211025224855.png)

## 匹配位置

![20211025225119](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20211025225119.png)

### 多行匹配 m

m

```js
var result = "I\nlove\njavascript".replace(/^|$/gm, "#");
console.log(result);
/*
#I#
#love#
#javascript#
*/
```

### \b 和\B

\b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 \$ 之间的位置

\b

```js
var result = "[JS] Lesson_01.mp4".replace(/\b/g, "#");
console.log(result);
// => "[#JS#] #Lesson_01#.#mp4#"
```

\B

```js
var result = "[JS] Lesson_01.mp4".replace(/\B/g, "#");
console.log(result);
// => "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"
```

### (?=p)和(?!p)

(?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p

(?=p)

```js
var result = "hello".replace(/(?=l)/g, "#");
console.log(result);
// => "he#l#lo"
```

(?!p)

```js
var result = "hello".replace(/(?!l)/g, "#");
console.log(result);
// => "#h#ell#o#"
```

(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置

### 位置的特性

对于位置的理解，我们可以理解成空字符 ""

把 /^hello$/ 写成 /^^hello$\$\$/，是没有任何问题的

```js
var result = /^^hello$$$/.test("hello");
console.log(result);
// => true
```

甚至可以写成更复杂的

```js
var result = /(?=he)^^he(?=\w)llo$\b\b$/.test("hello");
console.log(result);
// => true
```

也就是说字符之间的位置，可以写成多个

> 把位置理解空字符，是对位置非常有效的理解方式

### 案例

#### 不匹配任何东西的正则

/.^/

因为此正则要求只有一个字符，但该字符后面是开头，而这样的字符串是不存在的

#### 数字的千位分隔符表示法

比如把 "12345678"，变成 "12,345,678"

- 弄出最后一个逗号

```js
var result = "12345678".replace(/(?=\d{3}$)/g, ",");
console.log(result);
// => "12345,678"
```

- 弄出所有的逗号

```js
var result = "12345678".replace(/(?=(\d{3})+$)/g, ",");
console.log(result);
// => "12,345,678"
```

- 匹配其余案例

```js
var result = "123456789".replace(/(?=(\d{3})+$)/g, ",");
console.log(result);
// => ",123,456,789"
```

我们知道匹配开头可以使用 ^，但要求这个位置不是开头怎么办？
easy，(?!^)，

```js
var regex = /(?!^)(?=(\d{3})+$)/g;
var result = "12345678".replace(regex, ",");
console.log(result);
// => "12,345,678"
result = "123456789".replace(regex, ",");
console.log(result);
// => "123,456,789"
```

- 支持其他形式

"12345678 123456789" 替换成 "12,345,678 123,456,789"

此时我们需要修改正则，把里面的开头 ^ 和结尾 \$，修改成 \b

```js
var string = "12345678 123456789",
  regex = /(?!\b)(?=(\d{3})+\b)/g;
var result = string.replace(regex, ",");
console.log(result);
// => "12,345,678 123,456,789"
```

其中 (?!\b) 怎么理解呢？
要求当前是一个位置，但不是 \b 前面的位置，其实 (?!\b) 说的就是 \B。
因此最终正则变成了：/\B(?=(\d{3})+\b)/g

![20211025231142](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20211025231142.png)

### 格式化

千分符表示法一个常见的应用就是货币格式化

```js
function format(num) {
  return num
    .toFixed(2)
    .replace(/\B(?=(\d{3})+\b)/g, ",")
    .replace(/^/, "$$ ");
}
console.log(format(1888));
// => "$ 1,888.00"
```

### 验证密码问题

密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。
此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难

- 简化

不考虑“但必须至少包括 2 种字符”这一条件。我们可以容易写出

```js
var regex = /^[0-9A-Za-z]{6,12}$/g;
```

- 判断是否包含有某一种字符

```js
var regex = /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/;
```

- 同时包含具体两种字符

```js
var regex = /(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/;
```

- 答案

  我们可以把原题变成下列几种情况之一：
  同时包含数字和小写字母
  同时包含数字和大写字母
  同时包含小写字母和大写字母
  同时包含数字、小写字母和大写字母
  以上的 4 种情况是或的关系（实际上，可以不用第 4 条）

```js
var regex = /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[AZ]))^[0-9A-Za-z]{6,12}$/;
console.log(regex.test("1234567")); // false 全是数字
console.log(regex.test("abcdef")); // false 全是小写字母
console.log(regex.test("ABCDEFGH")); // false 全是大写字母
console.log(regex.test("ab23C")); // false 不足6位
console.log(regex.test("ABCDEF234")); // true 大写字母和数字
console.log(regex.test("abcdEF234")); // true 三者都有
```
