---
title: 三天学会算法
date: 2021-11-19 21:15:12
permalink: /pages/9eaae444f0d5b/
categories:
  - 面试题
  - 算法
tags:
  -
---

算法的设计真的很美,有时候会佩服设计的人真厉害

- <https://www.iamshuaidi.com/>
- <https://codetop.cc/#/home>
- <https://juejin.cn/book/6844733800300150797>

<!-- more -->

## 两数之和

<https://leetcode-cn.com/problems/two-sum/>

> 真题描述： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]

```js
function twoSum(nums, target) {
  const diff = new Map();
  const len = nums.length;
  for (let i = 0; i < len; i++) {
    const num = nums[i];
    // target-当前值的差值是否存在
    if (diff.get(target - num) !== undefined) {
      return [diff.get(target - num), i];
    }
    // 不存在则记录当前值
    diff.set(num, i);
  }
}
```

## 三数之和

<https://leetcode-cn.com/problems/3sum/>

> 真题描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

```js
const threeSum = function(nums, target) {
  // 用于存放数组结果
  let res = [];
  // 排序
  nums = nums.sort((a, b) => a - b);
  // 缓存length
  const len = nums.length;
  for (let i = 0; i < len; i++) {
    // 左指针j
    let j = i + 1;
    // 右指针k
    let k = len - 1;
    // 如果遇到重复的数字，则跳过
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    while (j < k) {
      // 三数之和小于0，左指针前进
      if (nums[i] + nums[j] + nums[k] < 0) {
        j++;
        // 处理左指针元素重复的情况
        while (nums[j] === nums[j - 1]) {
          j++;
        }
      } else if (nums[i] + nums[j] + nums[k] > 0) {
        // 三数之和大于0，右指针后退
        k--;
        while (nums[k] === nums[k + 1]) {
          k--;
        }
      } else {
        // 得到的目标组合，推入结果数组
        res.push([nums[i], nums[j], nums[k]]);
        // 左右指针一起前进
        j++;
        k--;
        // 若左指针元素重复，跳过
        while (nums[j] === nums[j - 1]) {
          j++;
        }
        // 若有指针元素重复，跳过
        while (nums[k] === nums[k + 1]) {
          k--;
        }
      }
    }
  }
  return res;
};
console.log(threeSum([-1, 0, 1, 2, -1, -4]));
```

## 回文字符串

<https://leetcode-cn.com/problems/RQku0D/>

> 真题描述：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串

```js
const validPalindrome = function(s) {
  // 缓存字符串长度
  const len = s.length;
  let i = 0;
  let j = len - 1;
  while (i < j && s[i] === s[j]) {
    i++;
    j--;
  }
  // 尝试判断跳过左指针元素后，字符串是否回文
  if (isPalindrome(i + 1, j)) {
    return true;
  }
  // 常识判断跳过右指针元素后，字符串是否回文
  if (isPalindrome(i, j - 1)) {
    return true;
  }
  // 工具方法，判断字符串是否回文
  function isPalindrome(st, ed) {
    while (st < ed) {
      if (s[st] !== s[ed]) {
        return false;
      }
      st++;
      ed--;
    }
    return true;
  }
  return false;
};
console.log(validPalindrome("abca"));
```

## 链表的合并

> 真题描述：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。

输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}

const mergeTwoLists = function(l1, l2) {
  // 定义头结点，确保链表可以访问
  let head = new ListNode();
  // cur 这里就是咱们的针
  let cur = head;
  // 针开始穿梭
  while (l1 && l2) {
    // 如果l1的节点值较小
    if (l1.val <= l2.val) {
      // 先串起l1的节点
      cur.next = l1;
      // l1往前一步
      l1 = l1.next;
    } else {
      cur.next = l2;
      l2 = l2.next;
    }
    // 针在串起一个节点后，也会往前走一步
    cur = cur.next;
  }
  cur.next = l1 !== null ? l1 : l2;
  return head.next;
};
const l1 = {
  val: 1,
  next: {
    val: 2,
    next: {
      val: 3,
      next: null,
    },
  },
};
const l2 = {
  val: 1,
  next: {
    val: 3,
    next: {
      val: 4,
      next: null,
    },
  },
};
console.log(mergeTwoLists(l1, l2));
```

## 链表的删除

> 真题描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

输入: 1->1->2
输出: 1->2
示例 2:
输入: 1->1->2->3->3
输出: 1->2->3

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}
const deleteDuplicates = function(head) {
  let cur = head;
  while (cur !== null && cur.next !== null) {
    if (cur.val === cur.next.val) {
      cur.next = cur.next.next;
    } else {
      cur = cur.next;
    }
  }
  return head;
};
console.log(
  deleteDuplicates({
    val: 1,
    next: {
      val: 1,
      next: {
        val: 3,
        next: null,
      },
    },
  })
);
```

## 链表删除，dummy

> 真题描述：给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。

输入: 1->2->3->3->4->4->5
输出: 1->2->5
示例 2:
输入: 1->1->1->2->3
输出: 2->3

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}
const deleteDuplicates = function(head) {
  if (!head || !head.next) {
    return head;
  }
  let dummy = new ListNode();
  dummy.next = head;

  let cur = dummy;
  while (cur.next && cur.next.next) {
    if (cur.next.val === cur.next.next.val) {
      let val = cur.next.val;
      cur.next = cur.next.next.next;
      while (cur.next && cur.next.val === val) {
        cur.next = cur.next.next;
      }
    } else {
      cur = cur.next;
    }
  }
  return dummy.next;
};

console.log(
  deleteDuplicates({
    val: 1,
    next: {
      val: 1,
      next: {
        val: 1,
        next: {
          val: 2,
          next: {
            val: 3,
            next: null,
          },
        },
      },
    },
  })
);
```

## 总结

- head 是链表
- cur 是指针
- dummy 是链表的前一项的虚拟节点，当 head 有可能发生改变时使用

## 快慢指针

> 真题描述：给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

给定一个链表: 1->2->3->4->5, 和 n = 2.
当删除了倒数第二个结点后，链表变为 1->2->3->5.

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}
const removeNthFromEnd = function(head, n) {
  // 初始化 dummy 结点
  const dummy = new ListNode();
  // dummy 指向头结点
  dummy.next = head;
  // 初始化快慢指针，均指向 dummy
  let fast = dummy;
  let slow = dummy;

  // 快指针闷头走 n 步
  while (n !== 0) {
    fast = fast.next;
    n--;
  }

  // 快慢指针一起走
  while (fast.next) {
    fast = fast.next;
    slow = slow.next;
  }

  // 慢指针删除自己的后继结点
  slow.next = slow.next.next;
  // 返回头结点
  return dummy.next;
};
console.log(
  removeNthFromEnd(
    {
      val: 1,
      next: {
        val: 2,
        next: {
          val: 3,
          next: {
            val: 4,
            next: {
              val: 5,
              next: null,
            },
          },
        },
      },
    },
    2
  )
);
```

## 链表的反转

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}
const reverseListNode = function(head) {
  if (!head || head.next) {
    return head;
  }
  let pre = null;
  let cur = head;
  while (cur !== null) {
    let next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  return pre;
};
console.log(
  reverseListNode(
    {
      val: 1,
      next: {
        val: 2,
        next: {
          val: 3,
          next: {
            val: 4,
            next: {
              val: 5,
              next: null,
            },
          },
        },
      },
    },
    2
  )
);
```

## 局部反转一个链表

> 真题描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转

输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL

```js
// 入参是头结点、m、n
const reverseBetween = function(head, m, n) {
  // 定义pre、cur，用leftHead来承接整个区间的前驱结点
  let pre, cur, leftHead;
  // 别忘了用 dummy 嗷
  const dummy = new ListNode();
  // dummy后继结点是头结点
  dummy.next = head;
  // p是一个游标，用于遍历，最初指向 dummy
  let p = dummy;
  // p往前走 m-1 步，走到整个区间的前驱结点处
  for (let i = 0; i < m - 1; i++) {
    p = p.next;
  }
  // 缓存这个前驱结点到 leftHead 里
  leftHead = p;
  // start 是反转区间的第一个结点
  let start = leftHead.next;
  // pre 指向start
  pre = start;
  // cur 指向 start 的下一个结点
  cur = pre.next;
  // 开始重复反转动作
  for (let i = m; i < n; i++) {
    let next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  //  leftHead 的后继结点此时为反转后的区间的第一个结点
  leftHead.next = pre;
  // 将区间内反转后的最后一个结点 next 指向 cur
  start.next = cur;
  // dummy.next 永远指向链表头结点
  return dummy.next;
};
```

## 环形链表

就是立 flag，等到下次发现 lfag 说明就是个环

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
// 入参是头结点
const hasCycle = function(head) {
  // 只要结点存在，那么就继续遍历
  while (head) {
    // 如果 flag 已经立过了，那么说明环存在
    if (head.flag) {
      return true;
    } else {
      // 如果 flag 没立过，就立一个 flag 再往
      head.flag = true;
      head = head.next;
    }
  }
  return false;
};
```

### 判断换的起点

第一次发现 flag 的时候就是环的起点

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
// 入参是头结点
const hasCycle = function(head) {
  // 只要结点存在，那么就继续遍历
  while (head) {
    // 如果 flag 已经立过了，那么说明环存在
    if (head.flag) {
      return head;
    } else {
      // 如果 flag 没立过，就立一个 flag 再往
      head.flag = true;
      head = head.next;
    }
  }
  return false;
};
```

### 快慢指针思路找起点

定义慢指针 slow，快指针 fast。两者齐头并进， slow 一次走一步、fast 一次 走两步。这样如果它们是在一个有环的链表里移动，一定有相遇的时刻。这个原理证明起来也比较简单：我们假设移动的次数为 t，slow 移动的路程就是 t，fast 移动的路程为 2t，假如环的长度为 s，那么当下面这个条件：

> 2t - t = s

也就是：

> t = s

满足时，slow 和 fast 就一定会相遇。反之，如果两者没有相遇，同时 fast 遍历到了链表的末尾，发现 next 指针指向 null，则链表中不存在环。

<https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/tu-jie-kuai-man-zhi-zhen-ji-qiao-yuan-li-5tz0/>

```js
var detectCycle = function(head) {
  // 快慢指针初始化指向 head
  let slow = head;
  let fast = head;
  // 快指针走到末尾时停止
  while (fast && fast.next) {
    // 慢指针走一步，快指针走两步
    slow = slow.next;
    fast = fast.next.next;
    // 快慢指针相遇，说明含有环
    if (slow == fast) {
      // 任一一节点指向头节点
      fast = head;
      // 同步向前进
      while (fast != slow) {
        fast = fast.next;
        slow = slow.next;
      }
      // 返回入口节点
      return fast;
    }
  }
  // 不包含环
  return null;
};
```

## 有效括号

> 题目描述：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

> 示例 1:

输入: "()"
输出: true

> 示例 2:

输入: "()[]{}"
输出: true

> 示例 3:

输入: "(]"
输出: false

> 示例 4:

输入: "([)]"
输出: false

> 示例 5:

输入: "{[]}"
输出: true

```js
// 用一个 map 来维护左括号和右括号的对应关系
const leftToRight = {
  "(": ")",
  "[": "]",
  "{": "}",
};

/**
 * @param {string} s
 * @return {boolean}
 */
const isValid = function(s) {
  // 结合题意，空字符串无条件判断为 true
  if (!s) {
    return true;
  }
  // 初始化 stack 数组
  const stack = [];
  // 缓存字符串长度
  const len = s.length;
  // 遍历字符串
  for (let i = 0; i < len; i++) {
    // 缓存单个字符
    const ch = s[i];
    // 判断是否是左括号，这里我为了实现加速，没有用数组的 includes 方法，直接手写判断逻辑
    if (ch === "(" || ch === "{" || ch === "[") stack.push(leftToRight[ch]);
    // 若不是左括号，则必须是和栈顶的左括号相配对的右括号
    else {
      // 若栈不为空，且栈顶的左括号没有和当前字符匹配上，那么判为无效
      if (!stack.length || stack.pop() !== ch) {
        return false;
      }
    }
  }
  // 若所有的括号都能配对成功，那么最后栈应该是空的
  return !stack.length;
};
```

## 每日温度问题

> 题目描述: 根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

> 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

理解动图：<https://www.bilibili.com/video/BV12t4y1274o/>

```js
```
