---
title: 正则表达式
date: 2021-10-26 09:14:11
permalink: /pages/44a1900f5237c/
categories:
  - 学习笔记
tags:
  -
---

《js 正则迷你书》
<https://github.com/qdlaoyao/js-regex-mini-book>

<!-- more -->

## 匹配字符

### 横向匹配

ab{2,5}c => abc abbc abbbc

### 纵向匹配

ab[123]c => ab1c ab2c ab3c

### 范围表示(字符组)

[1-9a-fA-F] => [123456789abcdefABCDEF]  
如果要表示-，可以这么写
[-123][123-][1\-23]

### 排除字符组

[^123] => 非 1 或 2 或 3

### 简写

![1635173224(1)](<https://cdn.jsdelivr.net/gh/wu529778790/image/blog/1635173224(1).png>)

### 匹配任意字段

[\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个。

### 量词

![1635173263(1)](<https://cdn.jsdelivr.net/gh/wu529778790/image/blog/1635173263(1).png>)

### 贪婪匹配与惰性匹配

![20211025224855](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20211025224855.png)

## 匹配位置

![20211025225119](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20211025225119.png)

### 多行匹配 m

m

```js
var result = "I\nlove\njavascript".replace(/^|$/gm, "#");
console.log(result);
/*
#I#
#love#
#javascript#
*/
```

### \b 和\B

\b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 \$ 之间的位置

\b

```js
var result = "[JS] Lesson_01.mp4".replace(/\b/g, "#");
console.log(result);
// => "[#JS#] #Lesson_01#.#mp4#"
```

\B

```js
var result = "[JS] Lesson_01.mp4".replace(/\B/g, "#");
console.log(result);
// => "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"
```

### (?=p)和(?!p)

(?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p

(?=p)

```js
var result = "hello".replace(/(?=l)/g, "#");
console.log(result);
// => "he#l#lo"
```

(?!p)

```js
var result = "hello".replace(/(?!l)/g, "#");
console.log(result);
// => "#h#ell#o#"
```

(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置

### 位置的特性

对于位置的理解，我们可以理解成空字符 ""

把 /^hello$/ 写成 /^^hello$\$\$/，是没有任何问题的

```js
var result = /^^hello$$$/.test("hello");
console.log(result);
// => true
```

甚至可以写成更复杂的

```js
var result = /(?=he)^^he(?=\w)llo$\b\b$/.test("hello");
console.log(result);
// => true
```

也就是说字符之间的位置，可以写成多个

> 把位置理解空字符，是对位置非常有效的理解方式

### 案例

#### 不匹配任何东西的正则

/.^/

因为此正则要求只有一个字符，但该字符后面是开头，而这样的字符串是不存在的

#### 数字的千位分隔符表示法

比如把 "12345678"，变成 "12,345,678"

- 弄出最后一个逗号

```js
var result = "12345678".replace(/(?=\d{3}$)/g, ",");
console.log(result);
// => "12345,678"
```

- 弄出所有的逗号

```js
var result = "12345678".replace(/(?=(\d{3})+$)/g, ",");
console.log(result);
// => "12,345,678"
```

- 匹配其余案例

```js
var result = "123456789".replace(/(?=(\d{3})+$)/g, ",");
console.log(result);
// => ",123,456,789"
```

我们知道匹配开头可以使用 ^，但要求这个位置不是开头怎么办？
easy，(?!^)，

```js
var regex = /(?!^)(?=(\d{3})+$)/g;
var result = "12345678".replace(regex, ",");
console.log(result);
// => "12,345,678"
result = "123456789".replace(regex, ",");
console.log(result);
// => "123,456,789"
```

- 支持其他形式

"12345678 123456789" 替换成 "12,345,678 123,456,789"

此时我们需要修改正则，把里面的开头 ^ 和结尾 \$，修改成 \b

```js
var string = "12345678 123456789",
  regex = /(?!\b)(?=(\d{3})+\b)/g;
var result = string.replace(regex, ",");
console.log(result);
// => "12,345,678 123,456,789"
```

其中 (?!\b) 怎么理解呢？
要求当前是一个位置，但不是 \b 前面的位置，其实 (?!\b) 说的就是 \B。
因此最终正则变成了：/\B(?=(\d{3})+\b)/g

![20211025231142](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20211025231142.png)

### 格式化

千分符表示法一个常见的应用就是货币格式化

```js
function format(num) {
  return num
    .toFixed(2)
    .replace(/\B(?=(\d{3})+\b)/g, ",")
    .replace(/^/, "$$ ");
}
console.log(format(1888));
// => "$ 1,888.00"
```

### 验证密码问题

密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。
此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难

- 简化

不考虑“但必须至少包括 2 种字符”这一条件。我们可以容易写出

```js
var regex = /^[0-9A-Za-z]{6,12}$/g;
```

- 判断是否包含有某一种字符

```js
var regex = /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/;
```

- 同时包含具体两种字符

```js
var regex = /(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/;
```

- 答案

  我们可以把原题变成下列几种情况之一：
  同时包含数字和小写字母
  同时包含数字和大写字母
  同时包含小写字母和大写字母
  同时包含数字、小写字母和大写字母
  以上的 4 种情况是或的关系（实际上，可以不用第 4 条）

```js
var regex = /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[AZ]))^[0-9A-Za-z]{6,12}$/;
console.log(regex.test("1234567")); // false 全是数字
console.log(regex.test("abcdef")); // false 全是小写字母
console.log(regex.test("ABCDEFGH")); // false 全是大写字母
console.log(regex.test("ab23C")); // false 不足6位
console.log(regex.test("ABCDEF234")); // true 大写字母和数字
console.log(regex.test("abcdEF234")); // true 三者都有
```

### 括号

#### 分组

/a+/ 匹配连续出现的 "a"，而要匹配连续出现的 "ab" 时，需要使用 /(ab)+/

```js
var regex = /(ab)+/g;
var string = "ababa abbb ababab";
console.log(string.match(regex));
// => ["abab", "ab", "ababab"]
```

#### 提取数据

- match

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
console.log(string.match(regex));
// => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]
```

> match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的
> 内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match
> 返回的数组格式是不一样的

- exec

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
console.log(regex.exec(string));
// => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]
```

- 也可以使用构造函数的全局属性 $1 至 $9 来获取

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
regex.test(string); // 正则操作即可，例如
//regex.exec(string);
//string.match(regex);
console.log(RegExp.$1); // "2017"
console.log(RegExp.$2); // "06"
console.log(RegExp.$3); // "12"
```

#### 替换

想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, "$2/$3/$1");
console.log(result);
// => "06/12/2017"
```

等价于

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function() {
  return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;
});
console.log(result);
// => "06/12/2017"
```

等价于

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function(match, year, month, day) {
  return month + "/" + day + "/" + year;
});
console.log(result);
// => "06/12/2017"
```

#### 反向引用

```js
var regex = /\d{4}(-|\/|\.)\d{2}(-|\/|\.)\d{2}/;
var string1 = "2017-06-12";
var string2 = "2017/06/12";
var string3 = "2017.06.12";
var string4 = "2016-06/12";
console.log(regex.test(string1)); // true
console.log(regex.test(string2)); // true
console.log(regex.test(string3)); // true
console.log(regex.test(string4)); // true
```

其中 / 和 . 需要转义。虽然匹配了要求的情况，但也匹配 "2016-06/12" 这样的数据

要求前后一致，就要使用反向引用

```js
var regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;
var string1 = "2017-06-12";
var string2 = "2017/06/12";
var string3 = "2017.06.12";
var string4 = "2016-06/12";
console.log(regex.test(string1)); // true
console.log(regex.test(string2)); // true
console.log(regex.test(string3)); // true
console.log(regex.test(string4)); // false
```

![20211026095240](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20211026095240.png)

注意里面的 \1，表示的引用之前的那个分组 (-|\/|\.)。不管它匹配到什么（比如 -），\1 都匹配那个同
样的具体某个字符。

我们知道了 \1 的含义后，那么 \2 和 \3 的概念也就理解了，即分别指代第二个和第三个分组

#### 括号嵌套

```js
var regex = /^((\d)(\d(\d)))\1\2\3\4$/;
var string = "1231231233";
console.log(regex.test(string)); // true
console.log(RegExp.$1); // 123
console.log(RegExp.$2); // 1
console.log(RegExp.$3); // 23
console.log(RegExp.$4); // 3
```

![20211026095431](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20211026095431.png)

#### \10

即 \10 是表示第 10 个分组

```js
var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/;
var string = "123456789# ######";
console.log(regex.test(string));
// => true
```

> 如果真要匹配 \1 和 0 的话，请使用 (?:\1)0 或者 \1(?:0)

#### 引用不存在的分组会怎样

因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配
反向引用的字符本身。例如 \2，就匹配 "\2"。注意 "\2" 表示对 "2" 进行了转义

```js
var regex = /\1\2\3\4\5\6\7\8\9/;
console.log(regex.test("\1\2\3\4\5\6\789"));
console.log("\1\2\3\4\5\6\789".split(""));
```

不同的浏览器和版本，打印的结果可能不一样

![20211026095830](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/20211026095830.png)

#### 分组后面有量词会怎样

分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配。

```js
var regex = /(\d)+/;
var string = "12345";
console.log(string.match(regex));
// => ["12345", "5", index: 0, input: "12345"]
```

从上面看出，分组 (\d) 捕获的数据是 "5"。
同理对于反向引用，也是这样的

```js
var regex = /(\d)+ \1/;
console.log(regex.test("12345 1"));
// => false
console.log(regex.test("12345 5"));
// => true
```

#### 非捕获性括号

如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。
此时可以使用非捕获括号 (?:p) 和 (?:p1|p2|p3)

```js
var regex = /(?:ab)+/g;
var string = "ababa abbb ababab";
console.log(string.match(regex));
// => ["abab", "ab", "ababab"]
```

```js
var regex = /^I love (?:JavaScript|Regular Expression)$/;
console.log(regex.test("I love JavaScript"));
console.log(regex.test("I love Regular Expression"));
// => true
// => true
```
